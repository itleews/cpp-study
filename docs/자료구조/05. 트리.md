# 05. 트리

## 05-1. 트리의 개념
- 데이터를 저장하고 탐색하기에 유용한 구조를 갖고 있음.
- 나무 기둥에서 가지가 뻗어나가는 모습을 거꾸로 뒤집어 놓은 모양

### 트리를 구성하는 노드
- 노드는 트리를 구성하는 요소
- 노드 중 가장 위에 있는 노드를 루트 노드(root node)라고 함.

### 노드를 연결하는 에지
- 노드와 노드 사이를 이어주는 선 → 이를 **간선** 또는 **에지(edge)**라고 함.
- 노드와 노드가 단방향 간선으로 연결되어 있고, 루트 노드에서 각 노드까지 경로는 유일함.
- 루트 노드로부터 특정 노드까지 거쳐가는 최소한의 간선 수를 레벨로 표현.

### 부모-자식, 형제 관계를 가지는 노드
- 간선으로 연결된 노드들은 서로 **부모-자식 관계**가 있다고 표현함.
- 간선으로 직접 연결된 노드 중 상대적으로 위에 있는 노드를 **부모 노드(parent node)**, 아래에 있는 노드를 **자식 노드(child node)**라고 함.
- 같은 부모 노드를 갖는 노드를 **형제 노트(sibling node)**라고 함.

### 자식이 없는 말단 노드
- 자식이 없는 노드는 **리프 노드(leaf node)**라고 함.

### 아래로 향하는 간선의 개수, 차수
- **차수(degree)**란 특정 노드에서 아래로 향하는 간선의 개수

---

## 05-2. 이진 트리 표현하기

### 배열로 표현하기
- 배열은 선형 자료구조이고, 트리는 계층 자료구조. 따라서, 배열로 트리를 표현하려면 3가지 규칙이 필요
    - 루트 노드는 배열 인덱스 1번에 저장함.
    - 왼쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 X 2**
    - 오른쪽 자식 노드의 배열 인덱스는 **부모 노드의 배 인덱스 X 2 + 1**

### 이진 트리 순회하기
순회란? 어떤 데이터가 있을 때 그 데이터를 빠짐없이 방문하는 것.
- 전위 순회(preorder): **현재 노드를 부모 노드로 생각했을 때** 부모 노드 → 왼쪽 자식 노드 → 오른쪽 자식 노드 순서로 방문 
- 중위 순회(inorder): **현재 노드를 부모 노드로 생각했을 때** 왼쪽 자식 노드 → 부모 노드 → 오른쪽 자식 노드 순서로 방문 
- 후위 순회(postorder): **현재 노드를 부모 노드로 생각했을 때** 왼쪽 자식 노드 → 오른쪽 자식 노드 → 부모 노드 순서로 방문 

### 포인터로 표현하기
- 포인터로 트리를 표현하려면 노드부터 정의해야 함.
- 노드는 노드의 값, 왼쪽 자식 노드와 오른쪽 자식 노드를 가짐.
- 포인터로 표현한 트리는 배열과 달리 인덱스 연산을 하지 않으므로 메모리 공간을 낭비하지 않으나 실제 노드를 따라가도록 구현해야 하므로 구현 난이도 높음.

### 인접 리스트로 표현하기
- 인접 리스트로 트리를 표현하려면 리스트를 노드 수만큼 만들어야 함.
- 각 리스트는 해당 정점의 자식 노드들이 됨.

### 각 표현 방법의 장단점
1. 배열
    - 장점: 구현이 쉽다.
    - 단점: 인덱스 연산으로 왼쪽 자식 노드와 오른쪽 자식 노드를 구분하므로 치우쳐진 트리를 구현하면 노드 수에 비해 공간을 많이 차지한다.

2. 포인터
    - 장점: 노드 개수만큼만 메모리 공간을 사용하므로 메모리 낭비가 크지 않다.
    - 단점: 노드를 표현하기 위해 포인터 공간이 필요하고, 구현 난이도가 높다.

3. 인접 리스트
    - 장점: 노드 개수만큼만 메모리 공간을 사용하고, 구현 난이도도 포인터에 비해 쉽다.
    - 단점: 특정 노드를 찾기 위해 연결 노드를 하나씩 따라가야 한다.

---

## 05-3. 이진 트리 탐색하기

### 이진 탐색 트리 구축하기
- 이진 탐색 트리는 데이터 크기를 따져 크기가 작으면 왼쪽 자쉭 위치에, 크거나 같으면 오른쪽 자식 위치에 배치하는 독특한 정렬 방식을 가짐.
- 즉, 삽입과 동시에 정렬

<br/>

- 이진 탐색 트리의 대상 데이터가 3 → 4 → 2 → 8 → 9 → 7 → 1 순서로 들어온다고 가정,
1. 최초의 데이터는 루트 노드가 됨. 3을 이진 탐색 트리에 루트 노드로 추가함.
2. 현재 삽입하려는 데이터는 4. 3보다 크므로 오른쪽 자식 위치에 배치함.
3. 현재 삽입하려는 데이터는 2. 2는 3보다 작으므로 왼쪽 자식 위치에 삽입함.
4. 현재 삽입하려는 데이터는 8. 8은 3보다 크므로 오른쪽 자식 위치를 봄. 이미 자식이 있는 경우 값을 비교 → 8은 4보다 크므로 오른쪽 자식 위치를 보고 위치가 비어 잇으므로 8을 배치함.
    - 이런 식으로 이진 탐색트리를 구축할 때는 넣으려는 대상 데이터의 값이 크거나 같으면 오른쪽 자식으로, 작으면 왼쪽 자식으로 배치함.
5. 9는 3보다 크므로 오른쪽. 4보다도 크므로 다시 오른쪽. 8보다도 크므로 오른쪽에 배치함.
6. 7은 3보다 크고, 4보다 크고, 8보다는 작으므로 8의 왼쪽 자식에 배치함.
7. 1은 3보다 작고, 2보다 작으니 2의 왼쪽 자식에 배치함.

### 이진 탐색 트리 탐색하기
1. 찾으려는 값이 현재 노드의 값과 같으면 탐색을 종료하고 크면 오른쪽 노드를 탐색함.
2. 본인이 찾으려는 값이 현재 노드의 값보다 작으면 왼쪽 노드를 탐색함.
3. 값을 찾으면 종료함. 노드가 없을 때까지 계속 탐색했는데 값이 없으면 현재 트리에 값이 없는 것.

### 이진 탐색 트리의 시간 복잡도
- 이진 탐색 트리의 시간 복잡도는 트리 균형에 의존함.
- 균형이 유지되었다고 가정했을 때 삽입과 탐색 연산 시 이진 탐색 트리에 저장된 노드가 N개라고 하면 시간 복잡도는 O(logN)