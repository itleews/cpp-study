# 00. 자료구조

## 00-1. 자료구조 (Data Structure)
- 데이터를 효율적으로 엑세스하고 조작할 수 있도록 데이터의 구조를 만들어 데이터를 저장하고 관리하는 것.
- 여러 가지 종류의 구조가 있으며, 각 자료구조마다 장단점이 있기 때문에 자신의 목적에 맞는 자료구조를 잘 선택하는 작업이 필요.
- 효과적으로 잘 설계된 자료구조는 실행시간을 최소화하고, 소요 공간을 최소한으로 사용하면서 연산을 수행할 수 있도록 해준다.

## 00-2. 추상적 자료형과 자료구조
- 특별한 구현방법을 지정하지 않은 자료형을 추상적 자료형(ADT)이라 부르는데, 추상적 자료형은 일반적으로 알고리즘이 문제를 해결하는데 필요한 자료의 형태와 그 자료를 사용한 연산들을 수학적으로 정의한 모델
- 추상적 자료형은 "무엇(What)"이 구현되어져야 하는지를 정의한 것으로 자료형의 논리적 형태를 정의하는 것이고, 자료구조는 이것을 "어떻게(How)" 구현할 지를 파악해서 물리적 형태로 구현하는 것.
- 일반적으로 잘 알려진 추상적 자료형: Stack, Queue, 우선순위 큐(Priority Queue), 데크(Double-ended Queue), Tree, Graph, Map, Associative Array, Set, List, Container 등등

## 00-3. 자료구조의 종류
1. 단순 구조: 프로그래밍에서 사용되는 기본적인 데이터 타입으로 정수, 실수, 문자, 부울린 등
2. 선형 구조: 자료 요소가 선형적으로 연결되어 있는 구조로서 앞 자료와 뒤 자료가 1대1인 구조
    - 배열, 선형 리스트, 스택, 큐 등
3. 비선형 구조: 자료 간 관계가 1대다 혹은 다대다 구조로서 계층구조 혹은 네트워크 망 구조를 가짐.
    - 트리, 그래프 등
4. 파일 구조: 레코드의 집합인 파일에대한 자료구조
    - 순차파일, 색인파일, 직접파일 등

## 00-4. 시간 복잡도란?
- 알고리즘의 성능을 나타내는 지표로, 입력 크기에 따른 연산 횟수를 의미.
- 시간 복잡도는 낮으면 낮을수록 좋음.
- O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

### 빅오 표기법(big-O notation)
- 최악의 경우에 대하여 상한선을 활용하여 시간 복잡도를 표현하는 방법.
- 어떤 프로그램의 연산 횟수가 f(x)라고 할 때 함수의 최고차항을 남기고 계수를 지워 O(...)와 같이 표기.

| 수식         | 빅오 표기 | 설명                                               |
|--------------|-----------|----------------------------------------------------|
|3x^2 + 5x + 6 | O(x^2)    | 다항함수로 구성되어 있으므로 최고차항  x^2만 남음. |
| x + logx     | O(x)      | 다항함수와 로그함수로 구성되어 있으므로 증가폭이 더 낮은 로그함수는 사라지고 다항함수만 남음. |
| 2^x + 10x^5 + 5x^2 | O(2^x) | 지수함수는 다항함수보다 빠르게 증가하므로 지수함수만 남음. |
| 5x^2 - 6x    | O(x^2)    | 최고차항 x^2만 남음.                               |


## 00-5. 자료구조 장단점 비교

## 배열(Array)
### ✅ 장점
- **빠른 접근 속도**: 인덱스를 이용한 O(1) 시간 복잡도로 원하는 요소에 접근 가능
- **연속된 메모리 할당**: 캐시 히트율이 높아 탐색 속도가 빠름

### ❌ 단점
- **고정된 크기**: 선언 시 크기를 지정해야 하며, 크기 변경이 어렵거나 비효율적
- **삽입 및 삭제 비용**: 중간에 삽입/삭제 시 O(n)의 시간 복잡도가 발생

---

## 연결 리스트(Linked List)
### ✅ 장점
- **동적 크기 조정**: 필요에 따라 크기를 조절할 수 있음
- **삽입 및 삭제 용이**: 중간에 요소 삽입/삭제 시 O(1) 시간 복잡도로 처리 가능

### ❌ 단점
- **느린 접근 속도**: 특정 요소 접근 시 O(n)의 시간 복잡도가 필요
- **추가적인 메모리 사용**: 각 노드가 다음 노드를 가리키는 포인터를 저장해야 함

---

## 스택(Stack)
### ✅ 장점
- **후입선출(LIFO) 구조**: 특정 알고리즘(예: DFS)에 유용
- **빠른 삽입 및 삭제**: O(1) 시간 복잡도로 push/pop 가능

### ❌ 단점
- **중간 요소 접근 불가**: 특정 요소를 검색하려면 O(n) 시간이 필요
- **고정 크기 (배열 기반 스택일 경우)**: 메모리 재할당이 필요할 수 있음

---

## 큐(Queue)
### ✅ 장점
- **선입선출(FIFO) 구조**: 작업 스케줄링 등에 적합
- **빠른 삽입 및 삭제**: O(1) 시간 복잡도로 enqueue/dequeue 가능 (원형 큐 기준)

### ❌ 단점
- **중간 요소 접근 불가**: 특정 요소를 검색하려면 O(n) 시간이 필요
- **배열 기반 큐는 크기 제한이 있음**: 크기를 초과하면 재할당이 필요

---

## 트리(Tree)
### ✅ 장점
- **정렬된 데이터 저장**: 이진 탐색 트리(BST) 구조를 사용하면 O(log n) 시간 복잡도로 검색 가능
- **다양한 형태로 확장 가능**: AVL 트리, B-트리, 트라이(Trie) 등 다양한 변형이 존재

### ❌ 단점
- **구현 복잡도**: 균형 유지 및 노드 삭제가 복잡할 수 있음
- **추가적인 메모리 사용**: 부모-자식 관계를 저장하기 위한 포인터 필요

---

## 해시 테이블(Hash Table)
### ✅ 장점
- **빠른 데이터 검색**: 평균적으로 O(1)의 시간 복잡도로 검색 가능
- **다양한 키를 이용한 데이터 저장**: 문자열, 숫자 등을 키로 사용 가능

### ❌ 단점
- **충돌 발생 가능**: 충돌 해결을 위한 추가 연산이 필요 (체이닝, 개방 주소법 등)
- **메모리 사용량 증가**: 해시 함수가 효율적이지 않으면 공간 낭비 발생

---

## 그래프(Graph)
### ✅ 장점
- **복잡한 관계 표현 가능**: 네트워크, 소셜 미디어 등 다양한 응용 가능
- **다양한 탐색 알고리즘 사용 가능**: DFS, BFS 등을 활용한 최단 경로 탐색 가능

### ❌ 단점
- **메모리 사용량 증가**: 인접 행렬 방식은 O(V²), 인접 리스트 방식도 추가적인 메모리 필요
- **탐색 비용 발생**: 특정 조건에서 최단 경로 탐색 시 O(V + E) 이상의 연산 필요

---